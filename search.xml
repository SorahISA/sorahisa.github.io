<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IOI 2021 場外心得</title>
    <url>/cp/contests/ioi21/</url>
    <content><![CDATA[<p>這是第一篇正式ㄉ文章ㄛ
&gt;////&lt;，本來該是另一篇的，但是因為太懶了還沒有動工，這篇就變成第一個了
www。</p>
<span id="more"></span>
<hr />
<p>前年的 IOI 2019 快結束的時候，看到 BB 搶下最後一題的首殺，拿到世界第
6
名，心情也不自覺的跟著變得激動雀躍，也讓我下定決心：只要還有認識的人在打，就一定要跟著看
scoreboard，甚至是同時打 Mirror（不知道為什麼 Yandex
沒開ㄌ），結果就變成線上了......</p>
<p>今年的 IOI 還是線上真的很可惜，少了那種在場外看著 scoreboard
跟著一起激動的感覺。當我想著自己一個人打會不會有點無聊的時候，正巧品庠來找我一起
virtual，就決定在 7/5 跟 7/7 的下午來打ㄌ！</p>
<hr />
<h2 id="day--2-day-0-----測試賽-nhdk-tpr">Day -2 ~ Day 0 --- 測試賽
&amp; NHDK TPR</h2>
<p>覺得自己需要稍微寫一下題目才不會燒雞，所以我就去找了測試賽的題目來打，但因為場外沒有今年的測試賽，所以我去
oj.uz 寫去年的測試題，發現有四分之三跟今年一樣ㄟ，賺到（X）。</p>
<p>反正也沒有限時，那就慢慢寫ㄅ。</p>
<ul>
<li><a href="https://oj.uz/problems/source/532">Judge</a></li>
</ul>
<h3 id="a---handcrafted-gift-gift">A - Handcrafted Gift (<a
href="https://oj.uz/problem/view/IOI20_gift">gift</a>)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(15\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(20\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(25\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(30\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>有一個長度 <span class="math inline">\(n\)</span> 的字串，每個字元是
<code>R</code> 或 <code>B</code>，你有 <span
class="math inline">\(r\)</span> 個任務，第 <span
class="math inline">\(i\)</span> 個任務要使 <span
class="math inline">\([a_i, b_i]\)</span> 恰有 <span
class="math inline">\(x_i\)</span>
種顏色，詢問有沒有合法的構造，有的話輸出任意一組。</p>
<ul>
<li><span class="math inline">\(n, r \le 500\,000\)</span>。</li>
<li><span class="math inline">\(x_i \in \{1, 2\}\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/440315">AC Solution</a></p>
<p>水題，把 <span class="math inline">\(x = 1\)</span> 的區間都 merge
起來剩下 RB 交錯放就好ㄌ。</p>
<h3 id="b---painting-squares-squares">B - Painting Squares (<a
href="https://oj.uz/problem/view/IOI20_squares">squares</a>)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(15\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(20\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(55\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>你需要完成兩個程式，第一個程式會給 jury 一個長度 <span
class="math inline">\(n\)</span> 的 01 陣列 <span
class="math inline">\(a\)</span> 和一個正整數 <span
class="math inline">\(k\)</span>，jury 會給你的第二個程式 <span
class="math inline">\(q\)</span> 段長度為 <span
class="math inline">\(k\)</span> 的 subarray <span
class="math inline">\(c = [a_x, a_{x+1}, \ldots,
a_{x+k-1}]\)</span>，你需要回傳這些 subarray 們在 <span
class="math inline">\(a\)</span> 的位置。</p>
<ul>
<li><span class="math inline">\(n, q \le 1000\)</span>。</li>
<li>給分方法：<span class="math inline">\(k \le 10\)</span> 滿分。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/441104">AC Solution</a> # <a
href="https://oj.uz/submission/440962">Random String</a></p>
<p>看到一眼就知道是要構造 de Bruijn sequence
的題目，但是忘記怎麼構造，所以先 random 生了一堆 01 字串來看看可以把
<span class="math inline">\(k\)</span> 壓到多少（BioInformatics 後遺症
www）。放了大約一小時最好的結果就是 <span class="math inline">\(k =
15\)</span>，就丟上去了。</p>
<p>想了幾個小時之後可恥的去看了 Wiki 寫了 inverse Burrows Wheeler
transform 過了。</p>
<p>有個小插曲是我中途交的所有 <span class="math inline">\(k \in [15,
20]\)</span> 的解也都拿到滿分，所以我就丟了一ㄍ issue
給他們，<del>不知道會不會被回 owo</del> 現在已經修好ㄌ
&gt;////&lt;。</p>
<h3 id="c---finding-routers-routers">C - Finding Routers (<a
href="https://oj.uz/problem/view/IOI20_routers">routers</a>)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(16\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(21\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(23\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(40\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>數線上 <span class="math inline">\([\,0, \ell\,]\)</span> 的位置放有
<span class="math inline">\(n\)</span> 座基地台，已知 <span
class="math inline">\(p_0 = 0, \quad p_i &lt; p_{i+1}\)</span> 且 <span
class="math inline">\(p_i \equiv 0 \pmod{2}\)</span>，你可以詢問他最多
<span class="math inline">\(q\)</span> 次離位置 <span
class="math inline">\(x\)</span>
最近的基地台在哪裡（相同距離就選左邊的），最後要回傳所有基地台的位置。</p>
<ul>
<li><span class="math inline">\(\ell = 100\,000\)</span>。</li>
<li><span class="math inline">\(n = 1000\)</span>。</li>
<li>給分方法：<span class="math inline">\(q \le 7500\)</span>
滿分。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/440944">AC Solution</a> # <a
href="https://oj.uz/submission/440817">Binary Search</a></p>
<p>詢問得到的陣列會長 <span class="math inline">\([\,0, \ldots, 1,
\ldots, i, \ldots, n-1\,]\)</span>
這樣子，每個數字都會出現至少一次且值非嚴格遞增。可以二分搜出每個 <span
class="math inline">\(p_c = x\)</span> 且 <span
class="math inline">\(p_{c+1} = x+1\)</span> 的位置並得到 <span
class="math inline">\(c\)</span> 就是 <span
class="math inline">\(x\)</span> 跟 <span
class="math inline">\(x+1\)</span> 的中點。這樣 query 的次數會是 <span
class="math inline">\(\mathcal{O}(n \lg \ell) \approx 20\,000\)</span>
次，拿到 <span class="score_70"><span
class="math inline">\(72.85\)</span> 分</span>。</p>
<p>不過，每一段的長度平均是 <span class="math inline">\(\frac{\ell}{n} =
100\)</span>，如果可以先花幾次把陣列分塊，大概就只需要再 <span
class="math inline">\(\mathcal{O}(n \lg \frac{\ell}{n}) \approx
7000\)</span> 次詢問。自然而然的就會想到用 CDQ
分治來做，實作也很簡單。</p>
<div class="note success"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> nL, <span class="type">int</span> nR, <span class="type">int</span> pL, <span class="type">int</span> pR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL &gt; nR <span class="keyword">or</span> pL &gt; pR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pL == pR) <span class="keyword">return</span> <span class="built_in">chmax</span>(last_place[<span class="built_in">use_detector</span>(pL)], pL), <span class="built_in">void</span>();</span><br><span class="line">    <span class="type">int</span> pM = pL + pR &gt;&gt; <span class="number">1</span>, nM = <span class="built_in">use_detector</span>(pM);</span><br><span class="line">    <span class="built_in">chmax</span>(last_place[nM], pM);</span><br><span class="line">    <span class="built_in">cdq</span>(nL, nM<span class="number">-1</span>, pL, pM<span class="number">-1</span>), <span class="built_in">cdq</span>(nM, nR, pM+<span class="number">1</span>, pR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>實際上自己 random 的一些測資，大約會 query <span
class="math inline">\(7200 \sim 7300\)</span> 次。</p>
<h3 id="d---jelly-flavours-jelly">D - Jelly Flavours (<a
href="https://oj.uz/problem/view/IOI20_jelly">jelly</a>)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(11\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(24\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(9\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(14\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(32\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>有 <span class="math inline">\(n\)</span> 本相異的書，第 <span
class="math inline">\(i\)</span> 本書在商店 A 跟商店 B 分別賣 <span
class="math inline">\(a_i\)</span> 跟 <span
class="math inline">\(b_i\)</span> 元。你現在沒帶錢，但有 A 商店的 <span
class="math inline">\(x\)</span> 元折價券跟 B 商店的 <span
class="math inline">\(y\)</span>
元折價券，請求出你最多可以買幾本相異的書。</p>
<ul>
<li><span class="math inline">\(n \le 2000\)</span>。</li>
<li><span class="math inline">\(0 \le x, y \le 10\,000\)</span>。</li>
<li><span class="math inline">\(0 \le a_i, b_i \le
10\,000\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/440487">AC Solution</a></p>
<p>每個物品只有 3 種狀態：不選、選 Store A、選 Store B。Subtask 3
提供了很重要的想法，如果先對 <span class="math inline">\(a_i\)</span>
排序，之後會發現存在一個位置 <span class="math inline">\(p\)</span>
使在區間 <span class="math inline">\([\,0, p)\)</span> 的物品都會在
Store A 或 Store B 買；在區間 <span class="math inline">\([\,p,
N)\)</span> 的物品都會在 Store B 買或是不會買。</p>
<div class="note info"><details>
<summary>
<h4>
簡單的證明
</h4>
</summary>
以 A、B、X 代表在 Store A 買、在 Store B 買、不買的狀態。如果存在一個 A
在 X 後面 <span class="math inline">\([A, B, A, {\color{red}X}, B,
{\color{red}A}, X, B, X]\)</span>，那把 A 跟 X 交換一定更好。
</details>
</div>
<p>剩下就是 DP 了。你需要計算在一個前綴如何用 A 取代掉 B 來使剩下的 B
盡量小，這邊是一個簡單的背包問題，然後後綴就直接暴力計算 B 從小到大 B
可以買幾個。維護前綴是 <span
class="math inline">\(\mathcal{O}(x)\)</span>；維護後綴是 <span
class="math inline">\(\mathcal{O}(n \lg n)\)</span>。</p>
<p>總複雜度是 <span class="math inline">\(\mathcal{O}(nx + n^2 \lg
n)\)</span>。</p>
<h3 id="nhdk-ten-point-round-7-div.-1">NHDK Ten Point Round #7 (Div.
1)</h3>
<ul>
<li><a
href="https://codeforces.com/group/H0qY3QmnOW/contest/316436">Contest
link</a></li>
</ul>
<p>7/4
晚上又一次覺得沒事做，想說來找一場感覺不會太難的比賽來打，就選到了 NHDK
辦ㄉ TPR ㄌ。</p>
<p>題目基本上都蠻簡單的（？，花了兩個小時慢慢把他寫完，就去睡覺ㄌ。</p>
<hr />
<h2 id="day-1">Day 1</h2>
<ul>
<li><a href="https://oj.uz/problems/source/576">Judge</a></li>
<li><a href="https://youtu.be/GVPBfpvT6V0">Screencast</a></li>
</ul>
<p>開始之前先把兩天的題目都印好，因為開始之後就沒辦法跑出去印ㄌ。</p>
<h3 id="a---分發糖果-distributing-candies-candies">A - 分發糖果 /
Distributing Candies (<a
href="https://oj.uz/problem/view/IOI21_candies">candies</a>)</h3>
<p><span class="score_10">分數：<span
class="math inline">\(11\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(3\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(8\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(27\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(29\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(33\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>給定一長度為 <span class="math inline">\(n\)</span> 的陣列 <span
class="math inline">\(c\)</span> 跟 <span
class="math inline">\(q\)</span> 次操作，你需要對一個長度為 <span
class="math inline">\(n\)</span> 且初始值為 <span
class="math inline">\(0\)</span> 的陣列 <span
class="math inline">\(a\)</span> 執行操作：</p>
<ol type="1">
<li><span class="math inline">\(\forall i \in [l_j, r_j], \quad a_i =
\min\{c_i, a_i + v_j\}\)</span>（放糖果進盒子）；</li>
<li><span class="math inline">\(\forall i \in [l_j, r_j], \quad a_i =
\max\{0, a_i - v_j\}\)</span>（從盒子拿糖果）。</li>
</ol>
<p>最後需要輸出 <span class="math inline">\(a\)</span>。</p>
<ul>
<li><span class="math inline">\(n, q \le 200\,000\)</span>。</li>
<li><span class="math inline">\(1 \le c_i \le 10^9\)</span>。</li>
<li><span class="math inline">\(1 \le v_j \le 10^9\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/441424"><span
class="math inline">\(\mathcal{O}(nq)\)</span> brute force</a> # <a
href="https://oj.uz/submission/441429"><span class="math inline">\(v_j
&gt; 0\)</span></a> # <a href="https://oj.uz/submission/441562"><span
class="math inline">\((l_i, r_i) = (0, n-1)\)</span></a></p>
<p>看到題目的第一眼覺得是<a
href="https://codeforces.com/blog/entry/57319">吉如一線段樹</a>裸題（至少
Subtask 3（盒子容量都相同）是裸題），因為回想起第一次在 IOIC
刻他花了大約 6
小時，而且這題看起來要維護最大、次大、最小、次小，所以把這題放在最後想。</p>
<p>Subtask 1（<span class="math inline">\(n, q \le
2000\)</span>）是暴力，本來以為 Subtask
2（只有加值）要用線段樹，後來發現差分就好了 owo。拿到 <span
class="score_10"><span class="math inline">\(11\)</span>
分</span>之後，覺得好像對 Subtask
4（每次操作都是全域）有點想法，發現了一些性質：</p>
<p>首先，可以把整個陣列排序，然後你會發現：</p>
<ol type="1">
<li>每個盒子剩下的空位（<span class="math inline">\(c_i -
a_i\)</span>）非嚴格遞增；</li>
<li>每次 <span class="math inline">\(\texttt{Add}(l_j, r_j,
v_j)\)</span> 操作完會有且僅有一段前綴是滿的（<span
class="math inline">\(\exists\,p \Rightarrow (i \in [\,0, p)
\Longleftrightarrow a_i = c_i)\)</span>）；</li>
<li>每次 <span class="math inline">\(\texttt{Sub}(l_j, r_j,
v_j)\)</span> 操作完會有且僅有一段前綴是空的（<span
class="math inline">\(\exists\,p \Rightarrow (i \in [\,0, p)
\Longleftrightarrow a_i = 0)\)</span>）。</li>
</ol>
<p>接下來的要做的事會長這樣：</p>
<ol type="1">
<li>找到操作後全空（或全滿）的前綴 <span class="math inline">\([\,0,
p)\)</span>；</li>
<li>給 <span class="math inline">\([\,0, p)\)</span>
那段區間一個代表全空（或全滿）的 tag；</li>
<li>更新前綴 <span class="math inline">\([\,0, p)\)</span>
跟後面的交界處（<span class="math inline">\(a_{p-1}\)</span> 跟 <span
class="math inline">\(a_p\)</span>）的差值。</li>
</ol>
<div class="note success"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> lo = <span class="number">0</span>, hi = N, mi;</span><br><span class="line">    <span class="keyword">if</span> (V[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/// nothing or full ///</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CheckVal</span>(N, i<span class="number">-1</span>) + V[i] &gt;= C[N].X) &#123;</span><br><span class="line">            <span class="built_in">RangeModify</span>(<span class="number">0</span>, N, <span class="number">-1</span>, i); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            mi = lo + hi &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">CheckVal</span>(mi, i<span class="number">-1</span>) + V[i] &gt;= C[mi].X) lo = mi + <span class="number">1</span>; <span class="comment">/// [0, mi] is full</span></span><br><span class="line">            <span class="keyword">else</span> hi = mi;                                         <span class="comment">/// [mi, N] is not full</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/// [0, lo) is full ///</span></span><br><span class="line">        <span class="built_in">PointModify</span>(lo, <span class="built_in">CheckVal</span>(lo, i<span class="number">-1</span>) - <span class="built_in">CheckVal</span>(lo<span class="number">-1</span>, i<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">RangeModify</span>(<span class="number">0</span>, lo<span class="number">-1</span>, <span class="number">-1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/// nothing or empty ///</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>要找一個位置當下的值，就紀錄「上次變空（或變滿）是什麼時候」，再看那時候到現在的每次操作的
<span class="math inline">\(v_j\)</span> 的和就好了。</p>
<div class="note success"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CheckVal</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> qID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// push tags from root to idx ///</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// pre_V[qID+1] - pre_V[last_change] ///</span></span><br><span class="line">    <span class="keyword">if</span> (seg[idx].last_type == <span class="string">&quot;Empty&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pre_V[qID] - pre_V[seg[idx].last_change];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (seg[idx].last_type == <span class="string">&quot;Full&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pre_V[qID] - pre_V[seg[idx].last_change] + C[idx].X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>求答案就是最後再問一輪就好ㄌ。</p>
<div class="note success"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) ans[C[i].Y] = <span class="built_in">CheckVal</span>(i, Q);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>最慘的是因為這題實作的部份想太久，最後來不及 de 完 bug，在<a
href="https://youtu.be/GVPBfpvT6V0?t=18360">結束後 6 分鐘</a>才拿到
<span class="score_20"><span class="math inline">\(29\)</span>
分</span>，虧豹 QwQ。</p>
<h3 id="b---鑰匙-keys-keys">B - 鑰匙 / Keys (<a
href="https://oj.uz/problem/view/IOI21_keys">keys</a>)</h3>
<p><span class="score_30">分數：<span
class="math inline">\(37\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(9\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(11\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(17\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(30\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(33\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>有一座地牢，<span class="math inline">\(n\)</span>
個房間每間都有一把不盡相異的鑰匙 <span
class="math inline">\(r_i\)</span>，且 <span
class="math inline">\(m\)</span> 條雙向通道 <span
class="math inline">\((u_j, v_j)\)</span> 每條都有一顆需要鑰匙 <span
class="math inline">\(c_j\)</span>
才能開的鎖（不會消耗鑰匙），你要輸出從哪些房間出發可以到達的房間數量最少。</p>
<ul>
<li><span class="math inline">\(n, m \le 300\,000\)</span>。</li>
<li><span class="math inline">\(0 \le r_i, c_j &lt; n\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/441446"><span
class="math inline">\(\mathcal{O}(nm)\)</span> DFS</a></p>
<p>前 3 個 Subtask 都有 <span class="math inline">\(n, m \le
2000\)</span>，用 <span class="math inline">\(n\)</span> 次 DFS
就拿到了，因為之前在 <a
href="https://drive.google.com/file/d/1G5kHW5mN6tPeCqVI_QxrnF3GaT0U_CHT">TPOJ
#6 pE</a> 看過一樣的題目，所以就很順利的拿到這 <span
class="score_30"><span class="math inline">\(37\)</span> 分</span>。</p>
<p>接下來想了很久，對後面的其他 Subtask 怎麼做都毫無頭緒。</p>
<h3 id="c---噴泉公園-fountain-parks-parks">C - 噴泉公園 / Fountain Parks
(<a href="https://oj.uz/problem/view/IOI21_parks">parks</a>)</h3>
<p><span class="score_50">分數：<span
class="math inline">\(55\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(5\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(15\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(20\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(20\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(30\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>有 <span class="math inline">\(n\)</span> 座噴泉，第 <span
class="math inline">\(i\)</span> 座噴泉在 <span
class="math inline">\((x_i,
y_i)\)</span>，座標兩兩相異且必為偶數，你需要判斷可不可行並規劃一種道路構建跟長椅擺放方式使</p>
<ul>
<li>每條道路長度皆為 <span class="math inline">\(2\)</span>
且連接兩座噴泉；</li>
<li>所有噴泉必須被道路們連通；</li>
<li>每條道路都有一張相鄰的長椅面向他（長椅的座標需為奇數）；</li>
<li>兩張長椅不能被放在同個位置。</li>
</ul>
<!-- -->
<ul>
<li><span class="math inline">\(n \le 200\,000\)</span>。</li>
<li><span class="math inline">\(2 \le x_i, y_i \le
200\,000\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/441398"><span
class="math inline">\(2 \le x_i \le 4\)</span></a> # <a
href="https://oj.uz/submission/441994">No <span class="math inline">\(2
\times 2\)</span> square</a></p>
<p>因為這題看起來最有趣就第一個做ㄌ。前兩個 Subtask 都有 <span
class="math inline">\(2 \le x_i \le
4\)</span>，就算把所有可以連的邊都連起來也只會像下面那樣，一定有解。</p>
<p><img data-src="Z7wVLiu.png" style="width: auto; max-width: 150px"></p>
<p>接下來感覺 Subtask 4（只有一種蓋道路的方式）好像可做，不過感覺跟
Subtask 5（沒有任四個噴泉形成 <span class="math inline">\(2 \times
2\)</span> 的方格）蠻像，都不會有像下面兩條<span
style="color:orange">橘線</span>或<span
style="color:blue">藍線</span>的情況，於是就想出一個跟 <span
class="math inline">\(\bmod 4\)</span> 相關的作法：</p>
<p><img data-src="r26XQWf.png" style="width: auto; max-width: 120px"></p>
<p>先隨便建一棵樹，對所有的<span style="color:red">平行 <span
class="math inline">\(y\)</span> 軸的邊（紅邊）</span>把 <span
style="color:blue"><span class="math inline">\(x + y \equiv 2
\pmod{4}\)</span> 的椅子（藍椅）</span>指給他；對所有<span
style="color:lime">平行 <span class="math inline">\(x\)</span>
軸的邊（綠邊）</span>把 <span style="color:#FFBF00"><span
class="math inline">\(x + y \equiv 0 \pmod{4}\)</span>
的椅子（黃椅）</span>指給他。</p>
<p><img data-src="oDF75lk.png" style="width: auto; max-width: 400px"></p>
<p>因為不會有上面平行相鄰的狀況，所以不用擔心一張椅子被指到兩條平行的邊。</p>
<div class="note success"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (X[u[i]] == X[v[i]]) &#123;</span><br><span class="line">        <span class="type">int</span> midY = (Y[u[i]] + Y[v[i]]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((X[u[i]] + <span class="number">1</span> + midY) % <span class="number">4</span> == <span class="number">2</span>) a[i] = X[u[i]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i] = X[u[i]] - <span class="number">1</span>;</span><br><span class="line">        b[i] = midY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Y[u[i]] == Y[v[i]]) &#123;</span><br><span class="line">        <span class="type">int</span> midX = (X[u[i]] + X[v[i]]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((Y[u[i]] + <span class="number">1</span> + midX) % <span class="number">4</span> == <span class="number">0</span>) b[i] = Y[u[i]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i] = Y[u[i]] - <span class="number">1</span>;</span><br><span class="line">        a[i] = midX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>有這 <span style="score_40"><span class="math inline">\(40\)</span>
分</span>讓我放心了許多，可是感覺有很多人會的 Subtask 3（<span
class="math inline">\(2 \le x_i \le
6\)</span>）一直沒有想法，燒雞的以為是位元 DP owo。</p>
<h3 id="小結">小結</h3>
<ul>
<li>Day 1 總分：<span class="score_10"><span
class="math inline">\(11\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_30"><span
class="math inline">\(37\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_50"><span
class="math inline">\(55\)</span></span><span
class="math inline">\({}={}\)</span><span class="score_30"><span
class="math inline">\(103\)</span> 分</span></li>
<li>Day 1 排名：<span class="medal_cu"><span
class="math inline">\(106\)</span></span><span
class="math inline">\(/351\)</span></li>
</ul>
<p>因為在 IOI 當下也有看 scoreboard，所以清楚的記得有三位選手拿到 <span
class="score_30"><span class="math inline">\(38\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_30"><span
class="math inline">\(37\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_70"><span
class="math inline">\(70\)</span></span><span
class="math inline">\({}={}\)</span><span class="score_40"><span
class="math inline">\(145\)</span> 分</span>，本來想說拿到 gift 的 <span
class="score_20"><span class="math inline">\(29\)</span>
分</span>可以補上不太會寫的大資結，結果耍廢到什麼都沒有 QwQ。</p>
<p>開場打好模板，看了約半小時的題目，就開始寫水分ㄌ。我的策略是先給一題一個小時的時間寫，如果可以拿到精神分數就先換題。</p>
<p>在 C 跟 A 拿到水分之後意外有了 C Subtask 4+5
的想法，多花了一點時間把他寫完，再把 B
的水分拿掉之後總共的時間也才過一半而已，不過有了之前 vir JOISC
的經驗，我知道這之後我就會開始思考力下降，就算吃ㄌ一條巧克力也不會變好。果然，思考了一個小時，實作又花了一個半小時，剛剛好在結束之後作完。</p>
<p>希望明天的 Day 2 可以打好一點 owo，至少可以到銀牌線上ㄅ
&gt;////&lt;。</p>
<hr />
<h2 id="day-2">Day 2</h2>
<ul>
<li><a href="https://oj.uz/problems/source/577">Judge</a></li>
<li><a href="https://youtu.be/62C07VDg_1g">Screencast</a></li>
</ul>
<h3 id="a---dna-突變-mutating-dna-dna">A - DNA 突變 / Mutating DNA (<a
href="https://oj.uz/problem/view/IOI21_dna">dna</a>)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(21\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(22\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(13\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(28\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(16\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>給定兩個長度 <span class="math inline">\(n\)</span> 且只包含
<code>A</code>、<code>T</code>、<code>C</code> 的字串 <span
class="math inline">\(a, b\)</span>，接下來會有 <span
class="math inline">\(q\)</span> 次詢問，每次給一段區間 <span
class="math inline">\([x, y]\)</span>，你需要計算 <span
class="math inline">\(a[x..y]\)</span>
最少需要經過幾次「交換兩個字元的位置」來變成 <span
class="math inline">\(b[x..y]\)</span>。</p>
<ul>
<li><span class="math inline">\(n, q \le 100\,000\)</span>。</li>
<li><span class="math inline">\(0 \le x \le y \le n-1\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/442137">AC Solution</a></p>
<p>今年最水 IOI
題，一開始看錯題以為是「交換兩個<strong>相鄰</strong>字元的位置」，結果交上去
WA 才發現根本不需要那麼麻煩 QAQ。</p>
<p>發現之後就把他水掉了，大概只有 Div2B ~ Div2C
左右的難度吧，但是這時已經經過兩個小時了，慘。</p>
<h3 id="b---地牢遊戲-dungeons-game-dungeons">B - 地牢遊戲 / Dungeons
Game (<a
href="https://oj.uz/problem/view/IOI21_dungeons">dungeons</a>)</h3>
<p><span class="score_50">分數：<span
class="math inline">\(50\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(11\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(26\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(13\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(12\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(27\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(11\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>有 <span class="math inline">\((n+1)\)</span> 座地牢，其中編號 <span
class="math inline">\(i\)</span> <span class="math inline">\((0 \le i
\le n-1)\)</span> 的地牢有一位力量為 <span
class="math inline">\(s_i\)</span> 的對手，假設英雄現在在地牢 <span
class="math inline">\(x\)</span> 並擁有 <span
class="math inline">\(z\)</span> 的力量：</p>
<ul>
<li>如果 <span class="math inline">\(x = n\)</span>，遊戲結束；</li>
<li>如果 <span class="math inline">\(z \ge s_x\)</span>，則 <span
class="math inline">\(z \leftarrow z + s_x\)</span> 且 <span
class="math inline">\(x \leftarrow w_x\)</span>（<span
class="math inline">\(w_x &gt; x\)</span>）；</li>
<li>如果 <span class="math inline">\(z &lt; s_x\)</span>，則 <span
class="math inline">\(z \leftarrow z + p_x\)</span> 且 <span
class="math inline">\(x \leftarrow l_x\)</span>。</li>
</ul>
<p>你需要進行 <span class="math inline">\(q\)</span>
次模擬，每次給你英雄的初始位置 <span class="math inline">\(x\)</span>
跟初始力量 <span
class="math inline">\(z\)</span>，請求出當遊戲結束時英雄的力量。</p>
<ul>
<li><span class="math inline">\(n \le 400\,000\)</span>。</li>
<li><span class="math inline">\(q \le 50\,000\)</span>。</li>
<li><span class="math inline">\(1 \le s_i, p_i, z \le
10^7\)</span>。</li>
<li><span class="math inline">\(0 \le w_i, l_i \le n\)</span>。</li>
<li><span class="math inline">\(0 \le x &lt; n\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/442807">AC Solution</a> # <a
href="https://oj.uz/submission/442812"><span class="math inline">\(n \le
50\,000\)</span></a> # <a
href="https://oj.uz/submission/442814">Doubling on <span
class="math inline">\(s_i = p_i\)</span></a> # <a
href="https://oj.uz/submission/442835"><span class="math inline">\(\#\{x
: x \in s\} = 1\)</span></a> # <a
href="https://oj.uz/submission/442827"><span class="math inline">\(\#\{x
: x \in s\} \le 5\)</span></a> # <a
href="https://oj.uz/submission/442142"><span
class="math inline">\(\mathcal{O}(q(n + C))\)</span> brute force</a></p>
<p>在寫這題之前先想到 Subtask 2（<span class="math inline">\(s_i =
p_i\)</span>）有個有趣的性質可以倍增，那就是如果英雄某一場打輸了，那他的力量至少會變成兩倍，所以就做
<span class="math inline">\(\mathcal{O}(\lg n)\)</span>
次「最多可以連勝到哪裡」就會到終點了，複雜度大約是 <span
class="math inline">\(\mathcal{O}(\lg n \lg
C)\)</span>。把暴力寫完之後也把倍增寫掉了，這時才發現倍增的作法可以一次過前兩筆
Subtask www。</p>
<p>接著還剩下約 70 分鐘，接下來只能想 Subtask 3（<span
class="math inline">\(\#\{x : x \in s\} = 1\)</span>）了，因為 Subtask 3
<span class="math inline">\(\subsetneq\)</span> Subtask 4 <span
class="math inline">\(\subsetneq\)</span> Subtask 5 <span
class="math inline">\(\subsetneq\)</span> Subtask 6。有了剛剛 Subtask 2
的倍增想法，這邊就變的很好想了，只要同樣用倍增維護「力量 <span
class="math inline">\(&lt; s_0\)</span> 走 <span
class="math inline">\(2^i\)</span> 步會到哪裡」跟「力量 <span
class="math inline">\(\ge s_0\)</span> 走 <span
class="math inline">\(2^i\)</span> 步會到哪裡」就能 AC
了，應該也很好寫......</p>
<p>結果我因為開的陣列層數剛剛好只有 <span
class="math inline">\(\lceil{\lg(50\,000)}\rceil = 16\)</span>
層，最後一層是代表可以一次走 <span class="math inline">\(2^{15} =
32\,768\)</span> 步的值，結果在某些測資會爛掉，花了 10
分鐘寫完卻花了一小時 debug，最後還是真的找不出 bug
於是就倍增做完亂暴力，意外的在 4:56:56 拿到這唬爛來的 <span
class="score_10"><span class="math inline">\(13\)</span>
分</span>。真是不知道該感到笑還是該哭呢 OwO。</p>
<p>話說，這題是前國手何達睿學長出的ㄛ
&gt;////&lt;，最後面有他的心得文喵。</p>
<h3 id="c---位元移位暫存器-bit-shift-registers-registers">C -
位元移位暫存器 / Bit Shift Registers (<a
href="https://oj.uz/problem/view/IOI21_registers">registers</a>)</h3>
<p><span class="score_10">分數：<span
class="math inline">\(10\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(11\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(12\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(25\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(13\)</span></span>$/ $<span
class="score_na"><span class="math inline">\(29\)</span></span><span
class="math inline">\()\)</span></p>
<div class="note info no-icon"><p>你有 <span class="math inline">\(100\)</span> 個容量 <span
class="math inline">\(2000\)</span> bits 的 register <span
class="math inline">\(r_0 \sim
r_{m-1}\)</span>，你可以進行以下操作：</p>
<ul>
<li><span class="math inline">\(\texttt{move}(t, y)\)</span>：<span
class="math inline">\(r_t = r_y\)</span>；</li>
<li><span class="math inline">\(\texttt{store}(t, v)\)</span>：<span
class="math inline">\(r_t = v\)</span>；</li>
<li><span class="math inline">\(\texttt{and}(t, x, y)\)</span>：<span
class="math inline">\(r_t = r_x \land r_y\)</span>；</li>
<li><span class="math inline">\(\texttt{or}(t, x, y)\)</span>：<span
class="math inline">\(r_t = r_x \lor r_y\)</span>；</li>
<li><span class="math inline">\(\texttt{xor}(t, x, y)\)</span>：<span
class="math inline">\(r_t = r_x \oplus r_y\)</span>；</li>
<li><span class="math inline">\(\texttt{not}(t, x)\)</span>：<span
class="math inline">\(r_t = \neg r_x\)</span>；</li>
<li><span class="math inline">\(\texttt{left}(t, x, p)\)</span>：<span
class="math inline">\(r_t = r_x \ll p\)</span>；</li>
<li><span class="math inline">\(\texttt{right}(t, x, p)\)</span>：<span
class="math inline">\(r_t = r_x \gg p\)</span>；</li>
<li><span class="math inline">\(\texttt{add}(t, x, y)\)</span>：<span
class="math inline">\(r_t = r_x + r_y\)</span>。</li>
</ul>
<p>一開始有 <span class="math inline">\(n\)</span> 個 <span
class="math inline">\(k\)</span>-bit 整數 <span
class="math inline">\(c_0 \sim c_{n-1}\)</span> 依序儲存在 <span
class="math inline">\(r_0\)</span>，其他所有 bits 皆為 <span
class="math inline">\(0\)</span>，你可以進行最多 <span
class="math inline">\(q\)</span> 次操作使：</p>
<ul>
<li><span class="math inline">\(s = 0\)</span>：<span
class="math inline">\(r_0\)</span> 在 <span class="math inline">\([\,0,
k)\)</span> 區間的 bits 需要是 <span
class="math inline">\(\min\limits_{0 \le i \le
n-1}\{c_i\}\)</span>；</li>
<li><span class="math inline">\(s = 1\)</span>：<span
class="math inline">\(r_0\)</span> 在 <span class="math inline">\([\,i
\cdot k, (i+1) \cdot k)\)</span> 區間的 bits 需要是 <span
class="math inline">\(c\)</span> 裡面第 <span
class="math inline">\(i\)</span> 小的數字。</li>
</ul>
<p>其他不在要求區間裡的 bit 可以是任意值。</p>
<ul>
<li>限制（<span class="math inline">\(s = 0\)</span>）：<span
class="math inline">\(n \le 100\)</span>、<span class="math inline">\(k
\le 10\)</span>、<span class="math inline">\(q = 150\)</span>。</li>
<li>限制（<span class="math inline">\(s = 1\)</span>）：<span
class="math inline">\(n \le 100\)</span>、<span class="math inline">\(k
\le 10\)</span>、<span class="math inline">\(q = 4000\)</span>。</li>
</ul>
</div>
<p><a href="https://oj.uz/submission/442197"><span
class="math inline">\(s = 0\)</span>、<span class="math inline">\(n =
2\)</span>、<span class="math inline">\(k \le 2\)</span>、<span
class="math inline">\(q = 1000\)</span></a></p>
<p>光是題目敘述就有整整 6 頁，而且他的左移和右移的方向跟 grader
輸出的方向又讓我頭昏腦脹，很久才理解要怎麼實作出東西來。</p>
<p>根據我在「數位電路設計」<del>學習</del>耍廢的經驗，對兩個 <span
class="math inline">\(2\)</span>-bit 的數字 <span
class="math inline">\(a, b\)</span>，有以下式子：</p>
<p><span class="math display">\[\min\{a, b\}_1 = a_1 \cdot
(\overline{a_1} \cdot \overline{a_0} + b_1 \cdot b_0 + \overline{a_1}
\cdot b_1) + b_1 \cdot \overline{(\overline{a_1} \cdot \overline{a_0} +
b_1 \cdot b_0 + \overline{a_1} \cdot b_1)} \notag\]</span></p>
<p><span class="math display">\[\min\{a, b\}_0 = a_0 \cdot
(\overline{a_1} \cdot \overline{a_0} + b_1 \cdot b_0 + \overline{a_1}
\cdot b_1) + b_0 \cdot \overline{(\overline{a_1} \cdot \overline{a_0} +
b_1 \cdot b_0 + \overline{a_1} \cdot b_1)} \notag\]</span></p>
<p>我就花了一個多小時在把這個寫出來，結果還用了 <span
class="math inline">\(26\)</span> 次操作，只有拿到 <span
class="score_10"><span class="math inline">\(10\)</span>
分</span>，然後我就放棄了。</p>
<h3 id="小結-1">小結</h3>
<ul>
<li>Day 2 總分：<span class="score_ac"><span
class="math inline">\(100\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_50"><span
class="math inline">\(50\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_10"><span
class="math inline">\(10\)</span></span><span
class="math inline">\({}={}\)</span><span class="score_50"><span
class="math inline">\(160\)</span> 分</span></li>
<li>Day 2 排名：<span class="medal_cu"><span
class="math inline">\(105\)</span></span><span
class="math inline">\(/351\)</span></li>
</ul>
<p>多虧有印出題目，不然電腦先卡了大約 20 分鐘應該就會先死去ㄌ www。</p>
<p>策略跟 Day 1 是一樣的，但是因為 dna 跟 register
都太特別了，導致今天根本沒能按照計畫進行。</p>
<p>嘛，題目應該要多讀幾次的，最好可以把自己的理解寫出來再對比一次，不然在「看錯題目」這種小錯誤上花整整一小時還是很燒雞ㄉ，還有有時候遇到真的超級麻煩的題目應該先不要管他，<del>只要祈禱大家都拿不到分數就好了</del>。</p>
<p>今天整體狀況比較平靜，多虧 dna
超水，讓我沒有遇到「會做卻沒時間做」的狀況（也有我直接把 register
當成實作題的原因啦），Day 2 花在<del>寫 code</del> debug 的時間就比 Day
1 多出不少呢，能跟 Day 1 有著幾乎相同的名次也很令我意外吶。</p>
<hr />
<h2 id="總結">總結</h2>
<ul>
<li>總分：<span class="score_10"><span
class="math inline">\(11\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_30"><span
class="math inline">\(37\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_50"><span
class="math inline">\(55\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_ac"><span
class="math inline">\(100\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_50"><span
class="math inline">\(50\)</span></span><span
class="math inline">\({}+{}\)</span><span class="score_10"><span
class="math inline">\(10\)</span></span><span
class="math inline">\({}={}\)</span><span class="score_40"><span
class="math inline">\(263\)</span> 分</span></li>
<li>排名：<span class="medal_cu"><span
class="math inline">\(104\)</span></span><span
class="math inline">\(/351\)</span></li>
<li>牌線：<span class="medal_au"><span
class="math inline">\(373\)</span></span><span
class="math inline">\(/\)</span><span class="medal_ag"><span
class="math inline">\(289\)</span></span><span
class="math inline">\(/\)</span><span class="medal_cu"><span
class="math inline">\(203\)</span></span></li>
</ul>
<p>如你所見，Day 1、Day 2、總排名呈等差數列，而且有越來越好的趨勢
www。如果 Day 1 再多 6 分鐘就有壓線銀牌ㄌ QwQ。</p>
<p>目前覺得最大的缺陷是沒有調整好自己的心態，對分數沒有執著，有點把這種
virtual 當成在玩的感覺（？</p>
<p>現在，平常在打 ICPC
的時候也是這樣，甚至連正式比賽都有點提不起勁。如果沒辦法對得獎、對分數有執著，基本上就只能當個休閒選手了吧......</p>
<p>希望這個暑假可以讓我重新拿回學習新東西的熱情ㄅ &gt;////&lt;。</p>
<hr />
<ul>
<li><a href="https://www.wiwiho.me/2021/07/01/ioi2021/">現任國手 WiwiHo
的比賽心得</a></li>
<li><a
href="https://hackmd.io/@E3-nUNPsRmy1gPXmWIt8jQ/r1yMcVOhu">前國手何達睿學長的
dungeons 出題心得</a></li>
</ul>
]]></content>
      <categories>
        <category>競程</category>
        <category>比賽心得</category>
      </categories>
      <tags>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title>MHC 2022 Qualification 比賽心得</title>
    <url>/cp/contests/mhc22-0/</url>
    <content><![CDATA[<p>今年開始 Facebook Hacker Cup 改叫 Meta Hacker
Cup，瞬間感覺變得高大上了 (X)，不過現在聽到 MHC
的簡寫完全無法直接反應過來 www。</p>
<span id="more"></span>
<div class="note primary"><p>如果你沒有打過 Meta Hacker Cup，可以參考看看
<a href="https://hackmd.io/@SorahISA-OIer/r1C5ZsT4F">這篇介紹文</a>。</p>
</div>
<h2 id="前言">前言</h2>
<p>雖然 Qualification 總共有三天、要什麼時候打都可以、也只要 AC
一題就能晉級，但是如果想要拿到高名次反而就只能選這種比較少電神會認真打的比賽了
www。</p>
<p>於是，目標就成形了：</p>
<ul>
<li>在 8/27 01:00 開始做題</li>
<li>把能寫的都寫完，能唬爛的都唬爛完
<ul>
<li>目標是在三個小時內全部 submit 成功</li>
<li><del>吃 FST 再說</del></li>
</ul></li>
<li>拿到盡量高的排名</li>
</ul>
<hr />
<h2 id="qualification-round">Qualification Round</h2>
<ul>
<li><a
href="https://www.facebook.com/codingcompetitions/hacker-cup/2022/qualification-round">Judge</a></li>
<li><a href="https://youtu.be/hsWBNidLFqY">Screencast</a></li>
</ul>
<p>因為是以破台為目標，所以基本上就是按照順序開題。開場先花了兩分鐘把東西整理好，就開始看題了～</p>
<h3 id="a.-second-hands">A. Second Hands</h3>
<p><span class="score_ac"><span class="math inline">\(9\)</span>
分</span> (6:17)</p>
<div class="note info no-icon"><p>你要把 <span class="math inline">\(N\)</span> 個正整數 <span
class="math inline">\(S_1, S_2, \ldots, S_N\)</span>
分成兩堆，使得兩堆的大小都 <span class="math inline">\(\le K\)</span>
且各自都不能包含重複的數字。<br/> 只要輸出 <code>YES</code> 或
<code>NO</code>，不用構造解法。</p>
<ul>
<li>測資數量<span class="math inline">\({} = 90\)</span>。</li>
<li><span class="math inline">\(1 \le N, K \le 100\)</span>。</li>
<li><span class="math inline">\(1 \le S_i \le 100\)</span>（<span
class="math inline">\(1 \le i \le N\)</span>）。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0A.cpp">AC
Solution</a></p>
<p>直觀的想法就是把出現兩次的數字都分開放，有出現三次以上的數字或是
<span class="math inline">\(N &gt; 2K\)</span> 就是
<code>NO</code>。</p>
<p>稍微想了一下就發現不用真的放數字，只要上面 <code>NO</code>
的條件不符合就會有解。</p>
<h3 id="b1.-second-friend">B1. Second Friend</h3>
<p><span class="score_ac"><span class="math inline">\(9\)</span>
分</span> (30:18)</p>
<div class="note info no-icon"><p>在 <span class="math inline">\(R \times C\)</span> 的格子裡有一些道路
<code>.</code> 跟樹木
<code>^</code>，你要在道路上種一些樹使得每一棵樹的四方位相鄰格子都只少有兩棵樹。<br/>
如果有解請輸出構造方法。</p>
<ul>
<li>測資數量<span class="math inline">\({} = 85\)</span>。</li>
<li><span class="math inline">\(1 \le R, C \le 100\)</span>。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0B.cpp">AC
Solution</a></p>
<p>我看到最上面說 B2 <span class="math inline">\(\supseteq\)</span> B1
之後就直接跳到 B2 了，所以我沒有看這題。</p>
<h3 id="b2.-second-second-friend">B2. Second Second Friend</h3>
<p><span class="score_ac"><span class="math inline">\(17\)</span>
分</span> (31:06)</p>
<div class="note info no-icon"><p>接 B1，在 <span class="math inline">\(R \times C\)</span>
的格子裡有一些道路 <code>.</code> 跟樹木 <code>^</code> <strong>跟石頭
<code>#</code></strong>。<br/></p>
<ul>
<li>測資數量<span class="math inline">\({} = 80\)</span>。</li>
<li><span class="math inline">\(1 \le R, C \le
\mathbf{3000}\)</span>。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0B.cpp">AC
Solution</a></p>
<p>第一眼的感覺是填滿會最好，不過因為有些位置會被石頭擋到只剩下一個
<em>氣</em>（定義一個位置的 <em>氣</em>
是他四方位相鄰的格子中可以種樹的位置數量），而那些只剩下 <span
class="math inline">\(0 \sim 1\)</span>
個氣的位置又會讓周圍的氣減少，於是要使用 DFS 來找所有會影響的位置。</p>
<p>寫了一堆 bug 讓我多花了 9 分鐘
QwQ。像是一開始把氣的初始值定義為周圍是道路或樹木的數量，結果 DFS
時又會把石頭周圍的氣都 <span
class="math inline">\(-1\)</span>，就導致石頭被扣兩次。</p>
<p>上傳的時候發現會燒雞，感覺是檔案太大的問題？於是就按照他們說的發了個
Clarification 附上 code 跟輸出 .zip 檔。</p>
<p>這時候我才發現每一題的名稱都有 Second www。</p>
<h3 id="c1.-second-meaning">C1. Second Meaning</h3>
<p><span class="score_ac"><span class="math inline">\(14\)</span>
分</span> (43:27)</p>
<div class="note info no-icon"><p>有一個神秘的語言，它總共有 <span class="math inline">\(N\)</span>
種符號，現在你希望只使用 <code>.</code> 跟 <code>-</code>
壓縮這個語言的任何訊息。<br/> 現在要求你第一種符號一定要壓縮成 <span
class="math inline">\(C_1\)</span>，請求出任何一組 <span
class="math inline">\(C_2, C_3, \ldots, C_N\)</span> 使得所有由
<code>.</code> 跟 <code>-</code> 構成的訊息都只有 <span
class="math inline">\(0\)</span> 或 <span
class="math inline">\(1\)</span> 種解讀方式。</p>
<ul>
<li>測資數量<span class="math inline">\({} = 100\)</span>。</li>
<li><span class="math inline">\(2 \le N \le 100\)</span>。</li>
<li><span class="math inline">\(1 \le |C_1| \le 100\)</span>。</li>
<li><span class="math inline">\(1 \le |C_i| \le 200\)</span>（<span
class="math inline">\(2 \le i \le N\)</span>）。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0C.cpp">AC
Solution</a></p>
<p>第一個想法是「只要所有符號壓縮後的長度都一樣就不會出現歧異」，不過給你的
<span class="math inline">\(C_1\)</span> 可能會超短（<span
class="math inline">\(\le 6\)</span>）讓我們沒辦法弄出 <span
class="math inline">\(N\)</span> 個相異字串。</p>
<p>那不如就把 <span class="math inline">\(C_1\)</span> 獨立出來看？讓
<span class="math inline">\(C_1\)</span>
的開頭跟其他人都不一樣，這樣讀到 <span
class="math inline">\(C_1[0]\)</span> 就知道是 <span
class="math inline">\(C_1\)</span>；讀到不是 <span
class="math inline">\(C_1[0]\)</span> 就知道是 <span
class="math inline">\(C_2, C_3, \ldots, C_N\)</span>，再讓 <span
class="math inline">\(C_2, C_3, \ldots, C_N\)</span> 的長度都相同就能把
<span class="math inline">\(C_1\)</span> 分出來了！</p>
<h3 id="c2.-second-second-meaning">C2. Second Second Meaning</h3>
<p><span class="score_ac"><span class="math inline">\(18\)</span>
分</span> (43:44)</p>
<div class="note info no-icon"><p>接 C1。</p>
<ul>
<li>測資數量<span class="math inline">\({} = 95\)</span>。</li>
<li><span class="math inline">\(2 \le N \le 100\)</span>。</li>
<li><span class="math inline">\(1 \le |C_1| \le 100\)</span>。</li>
<li><span class="math inline">\(1 \le |C_i| \le
\mathbf{10}\)</span>（<span class="math inline">\(2 \le i \le
N\)</span>）。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0C.cpp">AC
Solution</a></p>
<p>本來想說 C2 是給你 <span class="math inline">\(C_1, C_2, \ldots,
C_K\)</span> 求 <span class="math inline">\(C_{K+1}, C_{K+2}, \ldots,
C_N\)</span>（沒看題目被抓到），結果只是限制輸出長度要 <span
class="math inline">\(\le 10\)</span>，直接一起水掉 &gt;////&lt;。</p>
<p>C1 跟 C2 都上傳完之後看了一下輸出檢查有沒有弄錯檔案，結果發現我的
<code>Case #x:</code> 後面沒有換行，嚇死。</p>
<p>不過 validation 都有過，應該沒有差ㄅ？反正我又重新傳了一次。</p>
<blockquote>
<p>為什麼不要出到 <span class="math inline">\(|C_i| \le 7\)</span> 呢
OwO。</p>
</blockquote>
<h3 id="d.-second-flight">D. Second Flight</h3>
<p><span class="score_ac"><span class="math inline">\(33\)</span>
分</span> (91:40)</p>
<div class="note info no-icon"><p>有 <span class="math inline">\(N\)</span> 個城市，城市之間以 <span
class="math inline">\(M\)</span> 個航班 <span
class="math inline">\((A_i, B_i, C_i)\)</span> 連通。<br/>
每個航班在一天內會發 <span class="math inline">\(4\)</span> 班飛機，早晚
<span class="math inline">\(A_i \to B_i\)</span> 跟 <span
class="math inline">\(B_i \to A_i\)</span> 都各有一班，可以載 <span
class="math inline">\(C_i\)</span> 個 <strong>t</strong>ourists。<br/>
接著你會詢問 <span class="math inline">\(Q\)</span> 次 <span
class="math inline">\((X_j,
Y_j)\)</span>：在一天之內最多有多少人可以從城市 <span
class="math inline">\(X_j\)</span> 前往 <span
class="math inline">\(Y_j\)</span>。注意一個乘客一天之內最多可以搭乘兩個航班（早晚各一個）。</p>
<ul>
<li>測資數量<span class="math inline">\({} = 70\)</span>。</li>
<li><span class="math inline">\(1 \le N, M, Q \le
200\,000\)</span>。</li>
<li><span class="math inline">\(\sum\limits_{所有測資}{Q} \le
5\,000\,000\)</span>。</li>
<li><span class="math inline">\(1 \le A_i, B_i \le N\)</span>（<span
class="math inline">\(1 \le i \le M\)</span>）。</li>
<li>保證 <span class="math inline">\(A_i \ne
B_i\)</span>，且所有<strong>無序數對</strong> <span
class="math inline">\((A_i, B_i)\)</span> 皆相異（<span
class="math inline">\(1 \le i \le M\)</span>）。</li>
<li><span class="math inline">\(1 \le C_i \le 10^9\)</span>（<span
class="math inline">\(1 \le i \le M\)</span>）。</li>
<li><span class="math inline">\(1 \le X_j, Y_j \le N\)</span>（<span
class="math inline">\(1 \le j \le Q\)</span>）。</li>
<li>保證 <span class="math inline">\(X_j \ne Y_j\)</span>（<span
class="math inline">\(1 \le j \le Q\)</span>）。</li>
</ul>
</div>
<p><a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0D-1.cpp">AC
Solution (<span class="math inline">\(\texttt{bitset}\)</span>)</a> # <a
href="https://github.com/SorahISA/competitive_programming/blob/master/(MHC)%20Meta%20Hacker%20Cup/2022/Qualification%20Round/mhc22-0D-2.cpp">AC
Solution (<span
class="math inline">\(\texttt{unordered\_map}\)</span>)</a></p>
<p>一開始覺得跟最大流有關，不過發現只要看 <span
class="math inline">\((X_j, Y_j)\)</span> 有沒有邊以及枚舉中間點 <span
class="math inline">\(Z_j\)</span> 計算 <span
class="math inline">\(\min\{C_{(X_j, Z_j)}, C_{(Z_j, Y_j)}\}\)</span>
就能得到答案，我就覺得與其好好想解不如直接寫暴力 www。</p>
<p>不過 <span class="math inline">\(\mathcal{O}(QN)\)</span>
還是太大了，就算暴力也應該跑不完。</p>
<p>我決定來試試一個簡單的簡化法：把詢問過的答案存起來，並每次枚舉 <span
class="math inline">\(X_j\)</span> 跟 <span
class="math inline">\(Y_j\)</span> 度數小的去詢問大的有沒有。</p>
<p>把度數前 <span class="math inline">\(\mathcal{O}(\sqrt{N})\)</span>
大的點的鄰居存成 <code>bitset</code> 以求 <span
class="math inline">\(\mathcal{O}(1)\)</span> 查詢，如果 <span
class="math inline">\(X_j\)</span> 跟 <span
class="math inline">\(Y_j\)</span>
都是度數小的那群就直接線性掃過去（先把鄰居按照編號排序）。這樣複雜度就會變成
<span class="math inline">\(\mathcal{O}(Q\sqrt{N})\)</span>。</p>
<blockquote>
<p>其實是 <span class="math inline">\(\mathcal{O}(M
\sqrt{Q})\)</span>，我不會算複雜度 QwQ。<br/> 證明可以參考
<a href="https://www.facebook.com/codingcompetitions/hacker-cup/2022/qualification-round/solutions"><strong>官方的題解（Solution
2）</strong></a>。</p>
</blockquote>
<blockquote>
<p>寫到這裡我才發現其實把 <code>pair&lt;int, int&gt;</code> 壓成
<code>int64_t</code> 就可以用 <code>unordered_map</code> 了。<br/> 然後
<code>bitset</code> 跟整個 <code>adj[]</code> 也都可以被
<code>unordered_map</code> 取代掉，我 <code>bitset</code> 中毒 QwQ。</p>
</blockquote>
<p>光是 validation 就跑半分鐘了，所幸正式的 input
也大約兩分鐘就跑完了，不知道筆電如果開風扇會不會跑快一點。</p>
<blockquote>
<p>賽後才意識到 D 的輸出足足有 36 MB，不知道為什麼反而上傳的了？</p>
</blockquote>
<blockquote>
<p>做法可以參考
<a href="https://youtu.be/AbF6-TtkPLs?t=468">官方的影片解說</a>，我把上面的
Solution 1 改成 Solution 2 之後就跟其中一個官解幾乎一樣了。</p>
</blockquote>
<hr />
<h2 id="總結">總結</h2>
<ul>
<li>分數：<span class="score_ac"><span
class="math inline">\(100\)</span> 分</span></li>
<li>排名：<span class="medal_au"><span class="math inline">\(11 /
27\,603\)</span> 名</span></li>
</ul>
<p><img data-src="scoreboard.png" width="90%"></p>
<p>果然拿到了超高的名次，感覺 C 意外的水，而且 D
看題解才發現根號就是官解的複雜度，有種失望的感覺... 本來希望看到神奇的帶
<span class="math inline">\(\log\)</span> 作法的。</p>
<p>能用原定時間的一半多一點點破台是我沒想過的，不過自己感覺還有許多可以進步的地方<del>（像是剪指甲）</del>，接下來可能還有許多題目要出，剩下的就等
Round 1 再說ㄅ。</p>
]]></content>
      <categories>
        <category>競程</category>
        <category>比賽心得</category>
      </categories>
      <tags>
        <tag>MHC</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeroJudge c272. 趙哥的養成計畫 I --- 題解</title>
    <url>/cp/editorials/zj-c272/</url>
    <content><![CDATA[<h2 id="動機">動機</h2>
<p>刷
<a href="https://sites.google.com/site/pcshic/zi-xun-pei-xun">板中的講義題單</a>
的時候寫到了這一題，發現單純利用 sliding windows
過不了，花了大約四小時的時間去優化它才成功
AC。然後因為想寫題解，所以就順便來寫這一篇紀錄一下。</p>
<span id="more"></span>
<h2 id="題意">題意</h2>
<ul>
<li><a
href="https://zerojudge.tw/ShowProblem?problemid=c272">題目連結</a></li>
</ul>
<blockquote>
<p>給你 <span class="math inline">\(N\)</span>（<span
class="math inline">\(N \le 10\)</span>）個整數 <span
class="math inline">\(A_1 \sim A_N\)</span>（<span
class="math inline">\(|A_i| \le 10^6\)</span>）跟一個計分函式</p>
<p><span class="math display">\[score(i) = A_{\sigma_i} \times (M -
\min\{i, M + 1\} + 1) \notag\]</span> （<span
class="math inline">\(\sigma\)</span> 是一個 <span
class="math inline">\(1 \sim N\)</span> 的排列）。</p>
<p>接著有 <span class="math inline">\(Q\)</span>（<span
class="math inline">\(Q \le 10^6\)</span>）次詢問，請找出在分數不超過
<span class="math inline">\(qs\)</span>（<span
class="math inline">\(-2^{46} &lt; qs &lt;
2^{25}\)</span>）的前提下最多可以拿多少分。</p>
</blockquote>
<h2 id="暴力做法">暴力做法</h2>
<p>首先，C++ 裡可以透過
<a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation"><code>std::next_permutation()</code></a>
來找到所有排列，再依序計算出每個排列的分數。因為 <span
class="math inline">\(N \le 10\)</span>，所以排列個數 <span
class="math inline">\(P \le 10! =
3\,628\,800\)</span>。如果對每次詢問都重新查詢一遍，那複雜度會爛到 <span
class="math inline">\(\mathcal{O}(QP)\)</span>，顯然無法通過。</p>
<div class="note info"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) cin &gt;&gt; A[i];</span><br><span class="line"><span class="built_in">sort</span>(A, A + N);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* calculate score */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(A, A + N));</span><br></pre></td></tr></table></figure>
</details>
</div>
<h2 id="二分搜">二分搜</h2>
<p>不過因為每次詢問的排列都是相同的，先把所有排列的分數處理出來再利用二分搜（或直接用
<a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound"><code>std::prev(std::upper_bound())</code></a>）得到第一個
<span class="math inline">\(\le qs\)</span> 的最大值，複雜度是 <span
class="math inline">\(\mathcal{O}(Q \lg P)\)</span>，應該可以拿到 <span
class="math inline">\(51\)</span> 或 <span
class="math inline">\(61\)</span> 分。</p>
<h2 id="滑動窗口">滑動窗口</h2>
<p>這樣還是太慢了，觀察到 <span class="math inline">\(qs\)</span>
越大相應的答案就越大，考慮把所有詢問先拿出來排序，最後利用 sliding
windows 的方法維護答案，複雜度是 <span
class="math inline">\(\mathcal{O}(Q \lg Q + P)\)</span>，還是只能拿到
<span class="math inline">\(51\)</span> 或 <span
class="math inline">\(61\)</span> 分。</p>
<h2 id="常數優化-1">常數優化 1</h2>
<p>分數的最大值不會超過 <span class="math inline">\(\max\{A_i\} \times M
\le 10^7\)</span>，所以不用使用 <code>long long</code>，可以用
<code>int</code> 處理就好，但要注意的是 <span
class="math inline">\(qs\)</span> 的範圍會到
<code>long long</code>，可以先把他判斷掉。</p>
<div class="note info"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> qs;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">query</span>(Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; qs;</span><br><span class="line">    <span class="keyword">if</span> (qs &lt; all_score[<span class="number">0</span>]) qs = all_score[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">    query[i].first = qs, query[i].second = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<h2 id="常數優化-2">常數優化 2</h2>
<p>把所有 vector 都拔掉換成一般的 array、把區域變數開到全域、開
<code>#pragma GCC optimize("Ofast", "unroll-loops")</code>。</p>
<h2 id="io-優化">I/O 優化</h2>
<p>因為輸入大約有 <span class="math inline">\(6 \times 10^6\)</span>
個字元，輸出可能會到 <span class="math inline">\(2.5 \times
10^7\)</span> 個字元 (假設都是 <code>Case #xxxxx</code> 跟
<code>No Solution!</code>)，所以需要進行「適量」的優化。輸入跟輸出就選擇使用
<code>read()</code> 跟 <code>write()</code> 從 buffer
裡面一次讀進來跟印出去。</p>
<p>我的 I/O 模板是參考 FHVirus 的
<a href="https://fhvirus.github.io/blog/2020/fhvirus-io/">這篇
blog</a>，有興趣的人也可以去參考一下。</p>
<p>另外就是如果你是使用 <code>getchar()</code> 跟 <code>putchar()</code>
會拿到 <span class="math inline">\(74\)</span> 分，使用
<code>getchar_unlocked()</code> 跟 <code>putchar_unlocked()</code>
也可以拿到滿分。</p>
<h2 id="常數優化-3">常數優化 3</h2>
<p>因為不知道出題人是怎麼把空間壓到只有 <span
class="math inline">\(1.5\)</span> MB
的，所以就嘗試只當連續枚舉的答案不相同時才把答案加入陣列中，並把原本的滑動窗口改成二分搜，意外的直接拿到
TopCoder。</p>
<p><img data-src="https://i.imgur.com/lpSzrOH.png" /></p>
<div class="note info"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) score += A[i] * (M - i);</span><br><span class="line">    <span class="keyword">if</span> (score != all_score[all_score_sz<span class="number">-1</span>]) all_score[all_score_sz++] = score;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(A, A + N));</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>這個方法只要 <span class="math inline">\(N = M = 10\)</span>
就可以輕鬆卡掉，測資竟然沒出滿 OAO！</p>
<h2 id="ac-code">AC code</h2>
<ul>
<li><a
href="https://github.com/SorahISA/competitive_programming/blob/master/ZeroJudge/c/c272-1.cpp">滑動窗口</a></li>
<li><a
href="https://github.com/SorahISA/competitive_programming/blob/master/ZeroJudge/c/c272-2.cpp">二分搜</a></li>
</ul>
]]></content>
      <categories>
        <category>競程</category>
        <category>題解</category>
      </categories>
      <tags>
        <tag>ZeroJudge</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法概論－期中考</title>
    <url>/learning/nycu-introduction-to-algorithms/nycu-i2a-midterm/</url>
    <content><![CDATA[<p>好久沒發文了，電腦好像還有些東西沒設定好，沒辦法本機 deploy ;w;</p>
<span id="more"></span>
<hr />
<h2 id="準備階段">準備階段</h2>
<p>本來表定是 9:00 ~ 13:00 的，但是大家進教室之後就已經 9:00
了，還要測試環境，所以就延到 9:35 才開始。</p>
<p>先測一下 gcc 11.2 有支援什麼，發現不能直接
<code>#include &lt;bits/extc++.h&gt;</code>，會少東西，也不能宣告
<code>int _N</code>，他會說底線開頭的是預留字，但是可以宣告
<code>int _test</code> OwO。</p>
<p>在開始前約 10 分鐘，助教說今年的系統會跟以往的 Formosa OJ
不一樣，結果竟然是用 CMS！？而且還有計分板可以看，當下感覺好爽
&gt;////&lt;</p>
<div class="note info"><h4 id="想要-virtual-看看">想要 virtual 看看？</h4>
<p>如果你想要找有這些題目可以做跟上傳的地方，你可以來
<a href="https://oj.nctu.edu.tw/groups/36/problems/">這裡</a> 上傳。</p>
<p>請注意你會需要先 apply 這個
group，而要等教授按確認可能會需要幾天的時間（教授基本上都不會在意有誰要加
group）。</p>
</div>
<hr />
<h2 id="考試開始">考試開始</h2>
<p>可以直接用測機時打的模板耶！</p>
<p>本來的策略是先看過所有題目跟 Subtask
再去想要用什麼順序去寫，結果...</p>
<h3 id="b---spaghetti-tower-again-spaghetti">B - Spaghetti Tower Again
(Spaghetti)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(30\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(70\)</span></span><span
class="math inline">\()\)</span> (02:38) 全場首 Submit、全場首殺</p>
<blockquote>
<p>給你 <span class="math inline">\(N\)</span> 個正整數 <span
class="math inline">\(S_i\)</span>，接著詢問 <span
class="math inline">\(Q\)</span> 次有多少數字在 <span
class="math inline">\([l_i, r_i]\)</span> 內。</p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}30\%\)</span>：<span
class="math inline">\(N \le 10\,000\)</span>、<span
class="math inline">\(Q \le 5000\)</span>。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(N \le 1\,000\,000\)</span>、<span
class="math inline">\(Q \le 500\,000\)</span>、<span
class="math inline">\(1 \le S_i \le 10^9\)</span>。</li>
</ul>
</blockquote>
<p>顯然就是
<code>upper_bound(ALL(S), r) - lower_bound(ALL(S), l)</code>，花了一分鐘把東西刻完之後發現題本上的範測複製不起來，只能載他的
.zip 或是手打，於是就乾脆不測範例直接丟，然後他就 AC 了。</p>
<p>接著就把剩下的幾題看完，挑出最水的（已經有人 AC 的）F 來做。</p>
<h3 id="f---preventing-conflicts-conflicts">F - Preventing Conflicts
(Conflicts)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(10\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(90\)</span></span><span
class="math inline">\()\)</span> (06:50)</p>
<blockquote>
<p>給你兩個長度為 <span class="math inline">\(N\)</span> 的整數陣列
<span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>，請求出如果可以任意重新排列裡面的元素，變成
<span class="math inline">\(A&#39;\)</span> 跟 <span
class="math inline">\(B&#39;\)</span>，那 <span
class="math inline">\(\sum_{i=1}^{N}{A&#39;_i B&#39;_i}\)</span>
的最小值可以是多少。</p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}10\%\)</span>：<span
class="math inline">\(N \le 10\)</span>。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(N \le 100\,000\)</span>、<span
class="math inline">\(|A_i|, |B_i| \le 10\,000\)</span>。</li>
</ul>
</blockquote>
<p>經典題，讓 <span class="math inline">\(A\)</span> 順序 <span
class="math inline">\(B\)</span> 逆序，相乘就會最小。</p>
<p>因為剩下的題目感覺稍微有點麻煩，所以就先去開一眼就精神掉的 D。</p>
<h3 id="d---get-together-together">D - Get Together (Together)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(25\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(75\)</span></span><span
class="math inline">\()\)</span> (12:17) 首殺</p>
<blockquote>
<p>給你 <span class="math inline">\(N\)</span> 個人在數線上的初始位置
<span class="math inline">\(\ell_i\)</span> 以及速度 <span
class="math inline">\(v_i\)</span>，每個人可以往任意方向用至多 <span
class="math inline">\(v_i\)</span>
的速度移動，詢問使全部的人都到同一個位置上的最小時間。 精度誤差要 <span
class="math inline">\(\le 10^{-6}\)</span>。</p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}25\%\)</span>：<span
class="math inline">\(N \le
5000\)</span>、最佳解中，所有人會在整數點相遇。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(N \le 1\,000\,000\)</span>、<span
class="math inline">\(|\ell_i| \le 10^9\)</span>、<span
class="math inline">\(1 \le v_i \le 10^9\)</span>。</li>
</ul>
</blockquote>
<p>好好的對答案二分搜就能過了，作業裡有很多這樣的題目。</p>
<p>因為要對浮點數二分搜，所以要固定搜的次數才不會爆炸，我就直接設 <span
class="math inline">\(100\)</span> 次ㄌwww。</p>
<p>小插曲：因為慢慢的 C++20 中毒，所以我用了 <code>std::midpoint</code>
去求 <span
class="math inline">\(\frac{\ell+r}{2}\)</span>，交上去就吃了一發
CE。</p>
<p>剩下的題目就是：裸作業題 A、裸作業題 E、（把我打爆的）經典題
C，因為昨天看東區有一題是有帶權的 C，所以我就以為 C
會是防破台題，先丟一邊再說。</p>
<h3 id="a---yet-another-good-sequence-sequence">A - Yet Another Good
Sequence (Sequence)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(60\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(40\)</span></span><span
class="math inline">\()\)</span> (19:01)</p>
<blockquote>
<p>就是 <a href="https://oj.nctu.edu.tw/problems/1367/">作業</a>
的簡化版，你只能做 <span class="math inline">\(+1\)</span> 的操作，不能
<span class="math inline">\(-1\)</span>。</p>
<p><img data-src="https://i.imgur.com/LzT3CcF.png" /></p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}60\%\)</span>：<span
class="math inline">\(N \le 100\,000\)</span>。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(N \le 2\,000\,000\)</span>、<span
class="math inline">\(|a_i| \le 10^9\)</span>。</li>
</ul>
</blockquote>
<p>作業的版本還需要把左右 merge 起來，或是使用
<code>nth_element</code>，考試的簡化版直接往左右兩邊遞迴，回傳一個 <span
class="math inline">\((答案, 最大值)\)</span> 的 pair 就能更新ㄌ。</p>
<h3 id="e---awkwardness-continued-awkwardness">E - Awkwardness Continued
(Awkwardness)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(60\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(40\)</span></span><span
class="math inline">\()\)</span> (26:45) 首殺</p>
<blockquote>
<p>給你一棵 <span class="math inline">\(N\)</span>
個點的樹的合法前序跟中序表達，你要求出他的後序表達。</p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}60\%\)</span>：<span
class="math inline">\(N \le 10\,000\)</span>。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(N \le 2\,000\,000\)</span>、保證有解。</li>
</ul>
</blockquote>
<p>跟 <a href="https://oj.nctu.edu.tw/problems/1366/">作業</a>
一樣，而且求的是前序，更直觀了。</p>
<div class="note info"><details>
<summary>
範例 code
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tok = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(N)</span>, <span class="title">in</span><span class="params">(N)</span>, <span class="title">inv_in</span><span class="params">(N)</span>, post</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recur</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> rt = pre[tok++], p = inv_in[rt];</span><br><span class="line">    <span class="built_in">recur</span>(l, p<span class="number">-1</span>), <span class="built_in">recur</span>(p+<span class="number">1</span>, r);</span><br><span class="line">    post.<span class="built_in">emplace_back</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</div>
<p>小插曲：因為已經 C++20 中毒，所以我用了
<code>for (int tok = 0; int &amp;x : in) cin &gt;&gt; x, inv_in[--x] = tok++;</code>
又吃了一次 CE。</p>
<h3 id="c---amd-stocks-stocks">C - AMD Stocks (Stocks)</h3>
<p><span class="score_ac">分數：<span
class="math inline">\(100\)</span></span> $( $<span
class="score_ac"><span class="math inline">\(20\)</span></span>$/ $<span
class="score_ac"><span class="math inline">\(80\)</span></span><span
class="math inline">\()\)</span> (41:36)</p>
<blockquote>
<p>給你 <span class="math inline">\(N\)</span> 個區間 <span
class="math inline">\([s_i,
e_i]\)</span>，你要從中選出盡量多個區間使不存在任意位置被超過 <span
class="math inline">\(K\)</span> 個區間覆蓋。</p>
<p>限制：</p>
<ul>
<li><span class="math inline">\(\hphantom{0}20\%\)</span>：<span
class="math inline">\(K = 1\)</span>。</li>
<li><span class="math inline">\(100\%\)</span>：<span
class="math inline">\(1 \le K \le N \le 200\,000\)</span>、<span
class="math inline">\(1 \le s_i \le e_i \le 10^9\)</span>。</li>
</ul>
</blockquote>
<p>因為東區的題目，昨天剛好在討論這題帶權的做法，於是當下以為他很難。然後想了幾分鐘之後突然意識到昨天就討論過不帶權的作法ㄌ，只要
greedy 就能過。</p>
<p>當時沒有仔細的討論細節，所以當下我就直接跟著感覺走，刻了一棵區間加值查詢全域
max 的線段樹，所幸沒有太大的 bug，只有忘記端點離散化之後有 <span
class="math inline">\(2N\)</span> 個數字而吃了一次 WA。</p>
<h2 id="結語">結語</h2>
<p>就這樣，經過了考試約莫 <span
class="math inline">\(\frac{1}{6}\)</span>
的時間，成功破台了耶！本來聽說老師想把平均控制在 <span
class="math inline">\(40\)</span> 分（<span
class="math inline">\(40\%\)</span>
的意思）左右，又有整整四個小時可以寫，所以以為他會比競程一的期中考難，結果很失望（？</p>
<p>昨天在做怪怪的測機的時候，林栢瑋說我們應該要寫一個小時就出來不然不算分，這樣才好玩，沒想到真的可以在一個小時內破台
www。</p>
<p>出來之後意識到其實 C 已經寫過很多次了，去年競程也有這題，PCCA
團練也有這題，但是我每次都還是直接暴力砸線段樹下去做
._.，其實只要維護一個 <code>multiset</code> 就好了。</p>
<p>：「他一定能在 <span class="math inline">\(35\)</span>
分鐘破台。」<br/> ：「喔他寫線段樹喔，那沒救。」</p>
<p>88888888</p>
<p>希望期末考能夠有個夠難的防破台題，或是至少出一點有趣的題目（？</p>
]]></content>
      <categories>
        <category>競程</category>
        <category>比賽心得</category>
        <category>課業</category>
        <category>演算法概論</category>
      </categories>
  </entry>
</search>
